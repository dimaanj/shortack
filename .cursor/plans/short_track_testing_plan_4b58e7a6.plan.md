---
name: Short Track Testing Plan
overview: "Отдельный план по внедрению и расширению тестирования Short Track: юнит- и интеграционные тесты (Vitest), E2E (Playwright), опциональные скриншотные тесты, сценарии для уведомлений, дедупликации push, общей джобы по фильтрам, офлайна и аутентификации."
todos: []
isProject: false
---

# План тестирования Short Track

Текущее состояние: один юнит-тест в [packages/monitor-core/src/slot-diff.test.ts](shortack/packages/monitor-core/src/slot-diff.test.ts), Vitest настроен в `monitor-core` и в `queue` (скрипт есть, зависимость vitest в queue стоит проверить). В [apps/web](shortack/apps/web) тестов и Playwright нет.

---

## 1. Инфраструктура


| Что            | Где                            | Действие                                                                                                                      |
| -------------- | ------------------------------ | ----------------------------------------------------------------------------------------------------------------------------- |
| **Vitest**     | `apps/web`                     | Добавить vitest, скрипты `test` / `test:watch`, конфиг (например `vitest.config.ts`) с env/globals при необходимости.         |
| **Playwright** | корень монорепо или `apps/web` | Установить `@playwright/test`, `playwright.config.ts`, скрипт `e2e` в [package.json](shortack/package.json) или в `apps/web`. |
| **Coverage**   | Vitest                         | Включить `coverage` (v8 или istanbul) в конфиге; целевые пороги: core >80%, API >70% (как в основном плане).                  |
| **CI**         | существующий пайплайн          | На PR: `nx run-many -t test`; на merge/main: запуск E2E (staging или local).                                                  |


Ссылки на существующее: [shortack/package.json](shortack/package.json) (`"test": "nx run-many -t test"`), [packages/monitor-core/package.json](shortack/packages/monitor-core/package.json) (vitest).

---

## 2. Юнит-тесты (Vitest)

**2.1. packages/monitor-core**

- **slot-diff** — уже есть; при необходимости добавить кейсы: пустые `prev`/`curr`, только добавления, только удаления, дубли в одном массиве (если контракт это допускает).
- **date-utils** — новый файл `date-utils.test.ts`: `stringToDate`, `dateToString`, `addDays`, `getMaxFutureDateForMonitor` (границы, таймзона при фиксированной дате).

**2.2. packages/queue**

- Либо поднять Vitest в пакете (если ещё не установлен), либо покрыть вызовы из `apps/web` через интеграцию.
- Тесты для [packages/queue/src/monitor-poll-queue.ts](shortack/packages/queue/src/monitor-poll-queue.ts): логика `addMonitorPollJob` / `removeMonitorPollJob` с моком BullMQ Queue (например, in-memory или mock). После введения ключа по фильтрам (см. п. 6) — тест: один и тот же ключ `(fromId, toId, date)` не создаёт вторую repeatable job.

**2.3. apps/web — парсеры и утилиты**

- Тесты на парсеры API (без поднятия сервера):
  - `parseBody` в [apps/web/app/api/monitors/route.ts](shortack/apps/web/app/api/monitors/route.ts): валидный body, отсутствие полей, неверный формат даты.
  - `parseSubscription` в [apps/web/app/api/push/subscribe/route.ts](shortack/apps/web/app/api/push/subscribe/route.ts): валидный subscription, отсутствие keys/endpoint.
- Размещение: рядом с роутами (например `route.test.ts`) или в `__tests__` в `app/api`.

**2.4. Bus provider (парсинг)**

- [apps/web/lib/bus-provider/marshrutochka.ts](shortack/apps/web/lib/bus-provider/marshrutochka.ts): юнит-тесты на парсинг ответа перевозчика (мок HTML/JSON) → список слотов и форматы полей. Вынести парсер в чистую функцию, если сейчас всё завязано на HTTP.

---

## 3. Интеграционные тесты (API с моками)

- **Инструмент**: Vitest + при необходимости MSW или моки Firebase Admin / Redis в Node.
- **Маршруты**:
  - `GET/POST /api/monitors`, `GET/DELETE /api/monitors/[id]` — с моком Firestore и (при вызове queue) моком `addMonitorPollJob`/`removeMonitorPollJob`.
  - `POST /api/push/subscribe` — мок Firestore для сохранения подписки.
  - `GET /api/bus/slots` — мок `getAvailableTimeSlots` или контрактный ответ.
- **Цель**: проверка кодов ответа, формата JSON и того, что создание монитора вызывает добавление джобы (через mock).

---

## 4. E2E (Playwright)

**4.1. Настройка**

- `playwright.config.ts`: baseURL (localhost для dev или staging), один браузер для начала (e.g. chromium), при необходимости проекты для desktop/mobile.
- Запуск: либо `npx playwright test` из `apps/web`, либо из корня через nx.

**4.2. Сценарии**

- **Маршрут и слоты**: выбор from → to → дата → запрос слотов → отображение списка (с моком API или тестовым стендом перевозчика).
- **Монитор**: создание монитора (после ввода userId или после внедрения auth — см. п. 8) → появление в списке мониторов → остановка (DELETE) → исчезновение из списка или статус STOPPED.
- **Push (базово)**: подписка на push → создание монитора → проверка, что запрос подписки успешен и (если возможно в тесте) что уведомление приходит при появлении слотов (например через тестовый триггер или мок воркера).
- **Офлайн**: загрузка `/` и `/trips` → эмуляция offline → переход по страницам → проверка fallback (кэшированная страница или сообщение об отсутствии сети). При необходимости — проверка кэша для `GET /api/bus/slots` (ответ из кэша после отключения сети).

**4.3. Данные и стабильность**

- Фиксированные тестовые userId, маршруты и даты; при использовании реального API перевозчика — контракт или тестовый ключ, чтобы не зависеть от живых данных.

---

## 5. Скриншотные тесты (опционально)

- **Имеет смысл** для ключевых экранов: выбор маршрута (from/to + дата), список слотов, список мониторов, состояния «нет слотов» / «ошибка» / «офлайн».
- **Реализация**: встроенные snapshot Playwright (`expect(page).toHaveScreenshot()`) с моками данных и, при необходимости, фиксированным viewport и шрифтами.
- **Объём**: начать с 2–3 страниц; расширять при появлении регрессий.

---

## 6. Уведомления и дедупликация

**6.1. Функциональные тесты уведомлений**

- Юнит/интеграция: при `added.length > 0` вызывается отправка push с ожидаемым payload (title, body, url). Мок `getPushSubscriptionsByUserId` и `webPush.sendNotification`.
- Логику отправки по возможности вынести в отдельную функцию/модуль в [apps/web/workers/monitor-worker.ts](shortack/apps/web/workers/monitor-worker.ts), чтобы тестировать без поднятия воркера.

**6.2. Дедупликация (одно событие — один push)**

- **Правило**: один и тот же «факт появления слотов» (например, монитор + дата + набор added) не должен приводить к повторной отправке push одному и тому же пользователю в коротком окне (например 1–2 мин).
- **Реализация (на выбор)**: ключ события (например `monitorId + sorted(added).join(',')`) + хранение последних отправленных ключей с TTL в Redis/Firestore; или дебаунс по времени на уровне монитора.
- **Тесты**: два последовательных вызова «отправить уведомление» с одинаковым ключом события → отправка выполняется один раз; с разным ключом — два раза.

---

## 7. Одна джоба на набор фильтров (без параллельного запуска)

**7.1. Модель**

- Вместо одной repeatable job на каждый `monitorId` — одна repeatable job на уникальный `(fromId, toId, date)` (ключ, например `poll:${fromId}:${toId}:${date}`).
- Воркер по этому ключу: загружает все активные мониторы с такими фильтрами, один раз запрашивает слоты, для каждого монитора считает diff и шлёт push только при `added.length > 0`.

**7.2. Тесты**

- **Очередь**: при создании двух мониторов с одинаковыми from/to/date в очереди только одна repeatable job с данным ключом; при удалении одного монитора — джоба остаётся, при удалении всех — джоба снимается.
- **Воркер**: один запуск джобы обновляет `prevSlots` и при необходимости шлёт push всем пользователям с этими фильтрами.
- **Параллельность**: не запускать одну и ту же repeatable job в двух воркерах одновременно (BullMQ по умолчанию выдаёт один job на повтор; при необходимости — `concurrency: 1` для этой очереди или блокировка по ключу в Redis). Тест: два воркера + одна repeatable job — в любой момент только один job в статусе `active` для этого ключа (проверка через API очереди или Redis).

---

## 8. Офлайн

- **E2E**: см. п. 4.2 (офлайн после загрузки, навигация, fallback).
- **Сервис-воркер**: при желании — отдельные тесты (например в Node с jsdom или в браузере через Playwright): после запроса к `/api/bus/slots` и последующего offline повторный запрос возвращает кэшированный ответ (stale). Логика в [apps/web/public/sw.js](shortack/apps/web/public/sw.js) (stale-while-revalidate для `SLOTS_API_PREFIX`).

---

## 9. Аутентификация

- После внедрения NextAuth (или иного провайдера):
  - **Middleware**: тесты на то, что без сессии запросы к `GET/POST /api/monitors` и `POST /api/push/subscribe` возвращают 401 (или редирект для страниц).
  - **Привязка userId**: POST создания монитора использует `userId` из сессии; игнорирование переданного в теле `userId` (или отказ, если не совпадает).
  - **E2E**: логин → создание монитора → список мониторов содержит запись; логаут → список недоступен или пуст.
- В плане тестирования зафиксировать эти сценарии как обязательные после Phase 5.

---

## 10. Порядок внедрения и CI

1. **Фаза A**: Vitest в `apps/web`, юнит-тесты для парсеров API и date-utils; расширение тестов monitor-core; при необходимости — тесты queue с моком.
2. **Фаза B**: Интеграционные тесты API (моки Firestore/Redis/queue).
3. **Фаза C**: Playwright, 2–3 критичных E2E (маршрут+слоты, создание/остановка монитора).
4. **Фаза D**: Сценарии уведомлений и дедупликации (после реализации дедупа); сценарии общей джобы по фильтрам (после рефакторинга очереди).
5. **Фаза E**: Офлайн E2E; опционально скриншоты; тесты auth после Phase 5 продукта.

В CI: на PR — `lint`, `typecheck`, `nx run-many -t test` (и при наличии — `e2e` против локального или стабильного окружения); на merge в main — полный прогон E2E и деплой по текущей стратегии из основного плана.

---

## Связь с основным планом

- Цели покрытия и слои (unit / integration / E2E) согласованы с разделом «Tests Strategy» в [.cursor/plans/short_track_app_plan_b0e11aa2.plan.md](.cursor/plans/short_track_app_plan_b0e11aa2.plan.md).
- Реализация «одна джоба на фильтры» и «дедупликация push» — продуктовые фичи; план тестирования описывает, что и как проверять после их внедрения.
- Офлайн и auth — соответствуют Phase 4 и Phase 5 основного плана; тесты добавляются по мере реализации фич.

